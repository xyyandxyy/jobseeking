# Leecode 整理



* 23.合并K个升序链表: 

* 139单词拆分: 给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

  > 一维DP
  >
  > `dp[i]` 表示字符串s的前i个字符能否被字典中的单词拼接而成
  >
  > 状态转移: 对于位置i，我们检查所有可能的分割点j（0 ≤ j < i），如果：
  >
  > - `dp[j]` 为True（前j个字符可以拼接）
  > - 且 `s[j:i]` 在字典中存在
  > - 那么 `dp[i]` 就为True

* 198打家劫舍: 给定一个代表每个房屋存放金额的非负整数数组, 不能偷相邻的房屋，我们需要在这个约束下找到能偷到的最大金额

  > 一维DP, 对于每个房屋，我们有两个选择：偷或不偷
  >
  > 最大金额 = 当前房屋金额 + 前两个房屋的最大金额
  >
  > dp[i] 表示偷窃前 i+1 个房屋能获得的最大金额
  >
  > dp[i] = `max(dp[i-1], dp[i-2] + nums[i])`

* 200岛屿数量: 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

  >  遍历所有各自每当遇到'1'时岛屿数量+1, 并用DFS将整个连通的岛屿全部标记为'0'避免重复计算。

* 236二叉树的最近公共祖先: 给定一个二叉树(层次遍历表示的python array), 找到该树中两个指定节点的最近公共祖先。

  > 递归解决,
  >
  > 1. **递归终止条件**：如果当前节点为空，或者当前节点就是要找的两个节点之一，直接返回当前节点
  > 2. **递归搜索**：分别在左子树和右子树中搜索两个目标节点
  > 3. **判断逻辑**：
  >    - 如果两个目标节点分别在左右子树中找到，说明当前节点就是最近公共祖先
  >    - 如果只在左子树找到，说明最近公共祖先在左子树中
  >    - 如果只在右子树找到，说明最近公共祖先在右子树中

* 309.买卖股票的最佳时机含冷冻期: 维护3个状态的一维DP:

  > 给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。
  >
  > 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
  >
  > - 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

  这里说是股票, 其实就是反复买或卖同一个东西, 做倒爷赚钱.

  三个状态分别是:

  * 买(的收益): 只能从`手头没有`变过来, 或者延续昨天`买`完的持有状态
  * 卖(的收益): 只能从`买`的状态变过来
  * 手头没有(的收益), 且不是冷冻期: 只能从`卖`的状态解冻过来, 或者延续昨天`手头没有`的状态

  状态转移方程:

  - `hold[i]` = `max(hold[i-1], not_hold[i-1] - prices[i])` // 保持持有 或 从非冷冻期买入
  - `sold[i]` =` hold[i-1] + prices[i] `// 卖出股票进入冷冻期
  - `not_hold[i]` = `max(not_hold[i-1], sold[i-1]) `// 保持非冷冻期 或 从冷冻期恢复

* 416.分割等和子集: 给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

  > 0-1背包问题: 设target = sum(nums) // 2，问题变成"能否从nums中选择一些数字，使其和等于target"
  >
  > 状态定义：`dp[i][j] `表示前`i`个数字能否组成和为`j`
  >
  > 状态转移
  >
  > ：对于第i个数字nums[i-1]，有两种选择：
  >
  > - 不选：`dp[i][j] = dp[i-1][j]`
  > - 选择：`dp[i][j] = dp[i-1][j-nums[i-1]]`（前提是j >= nums[i-1]）
  >
  > 空间优化版本:
  > ``` 
  >     target = total_sum // 2
  >     
  >     # dp[j] 表示是否能组成和为j的子集
  >     dp = [False] * (target + 1)
  >     dp[0] = True  # 和为0的子集总是可能的（空集）
  >     
  >     # 遍历每个数字
  >     for num in nums:
  >         # 从后往前遍历，避免重复使用同一个数字
  >         for j in range(target, num - 1, -1):
  >             dp[j] = dp[j] or dp[j - num] # 去查询-num的是否为True
  > ```
  >
  > 

